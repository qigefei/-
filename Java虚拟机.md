# Java虚拟机

## Java内存模型--JMM(Java Memory Model)

* Java采用共享内存模型来实现多线程之间的信息交换和数据同步

### Java内存结构 即运行时的数据区域 （方法区、Java栈、本地方法栈、堆、程序计数器）

#### PC寄存器/程序计数器
一个数据结构，保存当前正在执行的程序的内存地址，每个线程都需要有独立的程序计数器，各个线程之间计数器互不影响。

#### Java栈 Java Stack
* 栈与线程关联起来，每创建一个线程，JVM就会为该线程创建对应的Java栈
* 每个Java栈包含多个栈帧(Stack Frame)，栈帧与方法相关联
* Java栈与线程对应，不是线程共有的，不需要关心数据一致性，也不存在同步锁的问题
* StackOverFlowError: 线程请求的栈深度大于虚拟机所允许的深度
* OutOfMemoryError: 虚拟机支持动态扩展，扩展时无法申请到足够的内存

#### 堆 Heap
* JVM管理内存中最大的一块，被所有Java线程共享，不是线程安全的，在JVM启动时创建
* 存储Java对象的地方
* GC管理的主要区域

#### 方法区
* 存放要加载的类的信息，类中的静态常量、类中定义为final类型的常量、类中的Field信息，类中的方法信息，当中程序中通过Class对象的getName等方法获取信息时，数据来源于方法区。
* 方法区被Java线程所共享，一定条件下会被GC，即通常所说的Java堆中的永久区，是堆中的一部分

#### 常量池
* 方法区中的一个数据结构，存储字符串，final变量值、类名和方法名常量
* 在编译期确定，保存在.class文件中
* 分为字面量和引用量
* 字面量:字符串、final变量等
* 引用量:类和接口的权限定名、字段的名称和描述符、方法的名称和描述符

#### 本地方法栈
* 本地方法 调用本地非Java代码
* 与Java栈类似，Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务

### 主内存和工作内存
* Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。
* 变量：包含实例字段、静态字段和构成数组对象的元素，不包含局部变量和方法参数(线程私有)，reference引用的对象在Java堆中可被线程共享，但reference引用本身在Java栈的局部变量表中，是线程私有的。
* JMM规定了所有变量都存储在主内存中，每个线程有自己的工作内存，线程的工作内存保存了该线程使用的变量的主内存的副本拷贝，线程操作都在工作内存中进行，不能直接读写主内存中的变量。
* 不同线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。

### Java内存模型围绕着原子性、可见性、有序性三个特征建立

#### 原子性
* 一个操作不能被打断，要么全部执行完毕，要么不执行。
* 32位的JVM会将64位数据分为2次32位的读写操作进行，导致long,double类型的变量在32位虚拟机中是非原子性的同时也是线程非安全

#### 可见性
* 一个线程对共享变量做了修改之后，其他线程立即能够看到(感知到) 该变量的这种修改
* Java内存模型通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性
* volatile保证volatile变量值修改后的新值立刻同步到主内存，每次使用volatile前立即从主内存中刷新，保证多线程之间操作变量的可见性
* synchromized关键字，在同步方法/块开始时，从主内存中刷新变量值到工作内存中，在同步方法/块结束时，将工作内存中的变量值同步到主内存中
* volatile/synchromized/lock/final都可以实现可见性

#### 有序性
* 单线程内观察，操作都是有序的：线程内表现为串行语义
* 在一个线程内观察另一个线程，所有的操作都是无序的：“指令重排“和”工作内存和主内存同步延迟现象“
* volatile关键字本身通过加入内存屏障来禁止指令的重排序
* synchronized关键字通过一个变量同一时间只允许有一个线程对齐加锁的规则来实现
* "指令重排"和"工作内存和主内存同步延迟"现象只在多线程程序中出现

### happens-before原则
* Java内存模型中定义的两项操作之间的次序关系，A先行发生于B，A产生的影响能被操作B观察到，"影响"包含了修改内存中共享变量的值，发送消息，调用方法等

#### 一些天然的happens-before关系

* 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作
* 管程锁定规则：unlock操作先行发生于后面对同一个锁的lock操作
* volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作
* 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
* 线程终于规则：线程中的所有操作都先行发生于对此线程的终止检测
* 线程中断规则：对现场interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
* 对象终结规则：一个对象初始化完成先行发生于它的finalize()方法的开始
* 传递性：A先于B，B先于C，可得出A先于C

## JVM类加载机制
### 类加载机制流程
#### 什么是类加载机制
* JVM把class文件加载到内存里面，并且对数据进行校验、准备、解析和初始化，最终能够形成JVM可以直接使用的Java类型的过程

#### 类加载的流程
* 加载-链接-初始化-使用-卸载

##### 加载
* 将class文件加载在内存中
* 将静态数据结构(数据存在于class文件的解构)转化成方法区中运行时的数据结构(数据存在于JVM时的数据结构)
* 在堆中生成一个代表这个类的java.lang.Class对象，作为数据访问的入口

##### 链接
链接就是将Java类的二进制代码合并到java的运行状态中的过程，包含 验证-准备-解析 三步

* 验证：确保加载的类符合JVM规范与安全
* 准备：为static变量在方法区中分配空间，设置变量的初始值
* 解析：虚拟机将常量池的符号引用转变为直接引用
	* 符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用于虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
	* 直接引用： 可以是直接指向目标的指针、相对偏移量或是一个能直接定位到目标的句柄。与虚拟机实现的内存布局相关，有了直接引用，引用的目标必行已经在内存中存在。

##### 初始化
初始化阶段是执行类构造器<client>()方法，它将有编译器自动收集类中的所有类变量的赋值动作和静态变量与静态语句块static{}合并

##### 使用
正常使用

##### 卸载
GC把无用对象从内存中卸载

### 类加载与初始化实际

#### 类加载时机
* 一个类真正被加载的时机是在创建对象的时候。最先加载拥有main方法的主线程所在类

#### 类初始化时机
* 主动引用(发生类初始化过程)
	* new一个对象
	* 调用类的静态成员(除了final常量)和静态方法
	* 通过反射对类进行调用
	* 虚拟机启动，main方法所在类被提前初始化
	* 初始化一个类，如果其父类没有初始化，则先初始化父类
* 被动引用(不会发生类的初始化)
	* 当访问一个静态变量时，只有真正声明这个变量的类才会初始化。(子类调用父类的静态变量，只有父类初始化，子类不初始化)
	* 通过数组定义类引用，不会触发此类的初始化
	* final变量不会触发此类的初始化，因为在编译阶段就存储在常量池中

### 分析类加载

	public class ClassLoaderProduce {
    	static int d=3;
    	static{
       	 System.out.println("我是ClassLoaderProduce类");
    	}
    	public static void main(String [] args){
       	int b=0;
       	String c="hello";
       	SimpleClass simpleClass=new SimpleClass();
       	simpleClass.run();
    	}
	}

	class SimpleClass{
    	static int  a=3;
    	static{
        	a=100;
        	System.out.println(a);
    	}

    	public SimpleClass(){
        	System.out.println("对类进行加载！");
    	}

    	public void run(){
        	System.out.println("我要跑跑跑！");
    	}
	}
	
* 步骤一：装载ClassLoaderProduce类，在方法区生成动态数据结构，并且在堆中生成java.lang.Class对象;然后进行链接
* 步骤二：初始化：把static{} 和静态变量合并存放在类构造器当中，对静态变量赋值
* 步骤三：执行main()方法，首先在栈中生成一个main方法的栈帧，定义变量b\c
* 步骤四：创建SimpleClass对象；跟上面步骤类似：加载-链接-初始化。

## JVM垃圾回收机制
### 垃圾回收的意义
- 程序员编写程序的时候不再需要考虑内存管理。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存

### 垃圾回收机制中的算法
- 发现无用信息对象
- 回收被无用对象占用的内存空间

#### 引用计数法
堆中每个实例都有一个引用计数，初始为1，被引用计数+1，反之-1，0时回收

* 优点：可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利
* 缺点：无法检测出循环引用

#### tracing算法 或 标记-清除算法
从一个节点GC ROOT开始，寻找对应的引用节点，递归寻找，剩余节点被认为是没有引用到的节点

可作为GC ROOT的对象：

* 虚拟机栈中引用的对象(本地变量表)
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中引用的对象

会造成内存碎片

#### compating或标记-整理算法
在标记-清除算法的基础上，进行了对象的移动，成本更高，但解决了内存碎片的问题。

基于Compaction算法的收集器实现中，一般增加句柄和句柄表。

#### copying算法
为了克服句柄的开销和解决堆碎片的垃圾回收。

将堆分为一个对象面和多个空闲面，当对象满了，基于copying算法的垃圾回收就从根集中扫描活动对象，复制到控线面，空闲面变成对象面，原来的对象面变成空闲面。

stop-and-copy算法，将堆分为对象面和空闲区域面，切换中程序暂停

#### generation算法
分代的垃圾回收策略，基于这样一个事实：不同的对象的生命周期是不一样的，对不同生命周期的对象可以采取不同的垃圾回收算法，以便提高回收效率。

##### 年轻代(Young Generation)：
* 所有新生成的对象都首先放在年轻代。年轻代的目标是尽可能快的收集掉生命周期短的对象
* 新生代内存按照8：1：1分为1个ede区和两个survivor区。回收时先将eden区存活对象复制到一个survivor区，然后清空eden区，当这个survivor0区满的时候，将两个区的存活对象复制到另一个survivor区，然后情况eden和这个survivor区(类似copying)
* 当survivor区无法倒腾的时候将存活对象直接存放到老年代，当老年代满的时候会触发一次full gc
* 新生代发生的GC也叫做(Minor GC),Minor GC发生的频率较高(YOUNG GC?)

##### 老年代(Old Generation):
* 在年轻代中经历了N次垃圾回收后存活的对象会放到老年代中
* 内存比新生代大很多(大概1：2)，老年代满时触发Major GC即Full GC，发生概率较低

##### 持久代(Permanent Generation):
用于存放静态文件

### 垃圾收集器
新生代使用：

* Serial收集器(复制算法)：新生代单线程收集器，简单高效
* ParNew收集器(停止-复制算法):新生代收集器，可认为Serial收集器的多线程版本，多核CPU表现更好
* Paraller Scavenge收集器(停止-复制算法)：并行收集器，追求高吞吐量，高效利用CPU

老年代使用：

* Serial Old(标记-整理算法)：老年代单线程收集器
* Paraller Old(停止-复制算法)：Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先
* CMS(标记-清理算法)：高并发、低停顿、追求最短GC回收停顿时间

### 垃圾收集器的执行机制
Scavenge GC: 在Eden申请空间失败时触发，对Eden区域进行GC
Full GC: 对整个堆进行整理，包括Young、Tenured、Perm。老年代被写满，持久代被写满，System.gc()被显示调用均会触发Full GC

### Java有了GC后依然会发生内存泄露
* 静态集合类的使用
* 各种连接
* 监听器的使用

## Java程序编译和运行的过程
* 源文件由编译器编译成字节码
* 字节码由Java虚拟机解释运行

由于Java程序既要编译也要经过JVM解释运行，所以Java又被称为半解释语言

### 例子

#### 第一步(编译)
创建完源文件后，程序会先被编译为.class文件。编译一个类时先编译这个类所依赖的类

编译后的字节码文件格式主要分为两部分：常量池和方法字节码

* 常量池：代码出现过的所有token(类名，成员变量名等等)以及符号引用(方法引用，成员变量引用等)
* 方法字节码：类中各个方法的字节码

#### 第二步(运行)
* 类的加载 在程序第一次主动使用类的时候，才会去加载类。即不得不用的时候才加载进来，而且只加载一次
* 类的运行

程序运行的详细步骤

* jvm进程从class path路径中找到对应的.class二进制文件，将类信息加载到运行时数据区的方法区内
* 找到主函数入口，开始执行main函数
* 加载依赖的类，在堆区中为一个新的依赖类实例分配内存，然后调用构造函数初始化实例，实例持有着指向方法区的依赖类的类型信息
* 当使用依赖类的方法时，JVM根据引用找到对象，然后根据对象持有的引用定位到方法区中的方法表，获得函数字节码的地址，开始运行函数

## 常用JVM配置参数

* Trace跟踪参数
* 堆的分配参数
* 栈的分配参数

### 在IDE后台打印GC日志
* eclipse配置
* IDEA配置

### Trace跟踪参数

打印GC的简要信息：

	-verbose:gc
	-XX:+printGC
	
打印GC的详细信息：

	-XX:+PrintGCDetails

打印GC发生的时间戳：

	-XX:+PrintGCTimeStamps

理解GC日志的含义：	

	[GC[DefNew: 4416K->0K(4928K), 0.0001897 secs] 4790K->374K(15872K), 0.0002232 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
	
新生代GC，方括号内部 “GC前该区域已使用容量->GC后该区域已使用容量(该内存区域总容量)”

方括号之外“GC前Java堆已使用容量->GC后Java堆已使用容量(Java堆总容量)”

指定GC log的位置：

	-Xloggc:log/gc.log

每一次GC前和GC后都打印堆信息： 

	-XX:+PrintHeapAtGC
	
监控类的加载：

	-XX:+TraceClassLoading
	
### 堆的分配参数

-Xmx -Xms:

指定最大堆和最小堆

	-Xmx20m -Xms5m
	
Java会尽量将total mem的值维持在最小堆，当超出最小堆范围时，再涨

-Xmn、-XX:NewRatio、-XX:SurvivorRatio:

* -Xmn 设置新生代大小
* -XX:NewRatio 新生代(eden+2*s)/老年代(不包含永久区)的值
* -XX:SurvivorRatio 设置两个Survivor和eden比值 8表示两个Survivor:eden=2:8

设置新生代为1M

	-Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetails
	
设置新生代为15M

	-Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails
	
设置新生代为7M

	-Xmx20m -Xms20m –Xmn7m -XX:+PrintGCDetails
	
设置新生代为7M，同时增加幸存代大小

	-Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails

设置新生代为7M，增加幸存代大小，设置新生代/老年代比值为1

	-Xmx20m -Xms20m -XX:NewRatio=1
	-XX:SurvivorRatio=2 -XX:+PrintGCDetails
	
适当减小幸存代大小，减少GC的次数

	-Xmx20m -Xms20m -XX:NewRatio=1
	-XX:SurvivorRatio=3 -XX:+PrintGCDetails

-XX:+HeapDumpOnOutOfMemoryError、-XX:+HeapDumpPath:

* -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件
* -XX:+HeapDumpPath 导出OOM的路径

-XX:OnOutOfMemoryError

* -XX:OnOutOfMemoryError 在OOM时执行一个脚本

堆的分配参数总结：

* 根据实际情况调整新生代和幸存代的大小
* 官方推荐新生代占堆的3/8
* 在OOM时Dump出堆，确保可以排查现场

-XX:PermSize -XX:MaxPermSize:

设置永久区的初始空间和最大空间

如果堆空间没有用完也抛出了OOM，可能是永久区溢出导致的

### 栈的分配参数

Xss:设置栈空间的大小，通常几百K，决定函数调用的深度，每个线程有独立的栈空间，局部变量、参数分配在栈上
