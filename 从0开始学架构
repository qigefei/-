从0开始学架构

第一讲 什么是架构
架构是顶层设计；
框架是面向编程或配置的半成品；
组件是技术维度上的复用；
模块是业务维度上职责的划分；
系统是相互协同可运行的实体。

第二讲 架构设计的历史背景
机器语言 -> 汇编语言-> 高级语言
结构化编程(模块) -> 面向对象编程(对象) -> 软件架构(组件)  拆分力度越来越粗，拆分层次越来越高

第三讲 架构设计的目的
架构设计的误区
	因为架构设计很重要，所以要做架构设计(正确的废话)
	每个系统都要做架构设计(知其然不知其所以然)
	公司流程要求系统开发过程中必须有架构设计
	为了高性能、高可用、可扩展所以要做架构设计(容易”大炮打蚊子”)
架构设计的真正目的
	架构设计的主要目的是解决软件复杂度带来的问题
	遵循该准则，做到心中有数，有的放矢，而不是贪大求全
	学生管理系统的案例
		性能：人数和访问次数不高，性能不复杂
		可扩展性：学生管理系统功能比较稳定，不复杂
		高可用：挂机队学生管理工作影响不大，负载均衡等要求不高，对存储高可靠要求高，考虑机器故障和机房故障，需要设计同机房主备和跨机房同步方案
		安全性：一般，需要acl控制，用户账号密码管理，数据库访问权限控制
		成本：几台服务器OK
	
第四讲 复杂度来源：高性能
体现在两方面：1.单台计算机内部为了高性能带来的复杂度 2.多台计算机集群为了高性能带来的复杂度
单机复杂度
	线程是操作系统调度的最小单位，共用进程内的资源 
	进程是操作系统分配资源的最小单位，与其他进程资源互相隔离
	手工操作 -> 批处理 ->  多进程分时 -> 多进程多线程 -> 多任务并行(SMP、NUMA、MPP)
集群复杂度
	任务分配(水平扩展)
	任务分解(架构拆分) 
		简单的系统更加容易做到高性能 
		可以针对单个任务进行扩展
总结
	1. 单台计算机内部为了高性能带来的复杂度
	2. 多台计算机集群为了高性能带来的复杂度

第五讲 复杂度来源：高可用
高可用的关键在于”无中断”
高性能增加机器的目的在于”扩展”处理性能，高可用增加机器目的在于”冗余”处理单元
计算高可用
存储高可用
	数据传输引入的复杂性
	存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响
	C(一致性)A(可用性)P(分区容错性)
高可用状态决策
	通过冗余来实现的高可用系统，状态决策本质上就不可能完全正确
	常见的决策方式
		独裁式
		协商式
		民主式

第六讲 复杂度来源：可扩展性
正确预测变化、完美封装变化
预测变化
	1. 不能每个设计点都考虑可扩展性
	2. 不能完全不考虑可扩展性
	3. 所有的预测都存在出错的可能性
应对变化
	两种常见方案
		1. 将”变化”封装在一个”变化层”，将不变的部分封装在一个独立的”稳定层”
		2. 提炼出一个”抽象层”和一个”实现层”

第七讲 复杂度来源：低成本、安全、规模
低成本
	往往只有”创新”才能达到低成本目标，引入或者创造新技术
安全
	功能安全 “防小偷”
	架构安全 “防强盗”
规模
	规模带来复杂度的主要原因是”量变引起质变”
		功能越来越多，导致系统复杂度指数级上升
		数据越来越多，系统复杂度发生质变
		
第8讲 架构设计三原则
合适原则 简单原则 演化原则
合适原则
	合适优于业界领先
简单原则
	简单优于复杂
	软件的复杂性体现
		结构的复杂性(例如随着组件数增多增加的复杂性)
		逻辑的复杂性(所有逻辑功能在一个组件中实现导致的逻辑复杂性)
演化原则
	演化优于一步到位
	软件架构设计更类似于大自然”设计”一个生物，通过演化让生物适应环境，逐步变得更加强大
合适优于先进 -> 演化优于一步到位 -> 简单优于复杂
合适首当其冲，在不断演化的大前提下尽量追求简单

第9讲 架构设计原则案例
淘宝
	个人网站->Oracle/支付宝/旺旺->Java->分布式
手机QQ
	10万级->百万级->千万级->亿级

第10讲 架构设计流程：识别复杂度
架构设计第一步，识别复杂度
判断复杂度来源于”高性能”、”高可用”、”可扩展”等具体某方面或某几方面
将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题
可以采用”排查法”
	是否需要高性能？
	是否需要高可用性？
	是否需要高扩展性？

第11讲 架构设计流程：设计备选方案
几种常见的架构设计误区
1. 设计最优秀的方案。不要面向”简历”进行架构设计，而要根据”合适”、”简单”、”演进”的架构设计原则，决策出与需求、团队、技术能力相匹配的合适方案
2. 只做一个方案。一个方案容易陷入思考问题片面，自我坚持的认知陷阱
备选方案设计的注意事项
1. 备选方案不要过于详细。备选阶段解决的是技术选型问题，而不是技术细节。
2. 备选方案的数量以3-5个为最佳
3. 备选方案的技术差异要明显
4. 备选方案不要只局限于已经熟悉的技术
做事情永远要有plan B甚至plan C

第12讲 架构设计流程：评估和选择备选方案
选择方案的挑战
	1. 每个方案都是可行的
	2. 没有方案是完美的
	3. 评价标准主观性比较强
360度环评
	列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案

第13讲 架构设计流程：详细方案设计
将方案涉及的关键技术细节确定下来
这个阶段的技术方案都是很轻量级的
详细设计方案阶段发现备选方案不可行，一般情况下的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性
如何避免？
1. 架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解
2. 通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度
3. 如果方案本身复杂，就采取设计团队的方式来进行设计

第14讲 高性能数据库集群：读写分离
将数据库读写操作分散到不同的节点上
1. 数据库搭建主从集群，一主一从，一主多从都可以
2. 数据库主机负责读写操作，从机只负责读操作
3. 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据
4. 业务服务器将写操作发给数据库主机，将读操作发给数据库从机
设计复杂度的来源
1. 主从复制延迟
2. 分配机制
复制延迟的常见解决方法
1. 写操作后的读操作指定发给数据库主服务器
2. 读从机失败后再读一次主机
3. 关键业务读写操作全部指向主机，非关键业务采用读写分离
分配机制的方案
1. 程序代码封装
2. 中间件封装

第15讲高性能数据库集群：分库分表
单台数据库服务器存储能力成为瓶颈体现的方面：
1. 数据量太大，读写性能下降，索引空间增大
2. 数据文件变得很大，数据备份和恢复需要很长时间
3. 数据文件越大，极端情况下丢失数据的风险越高
业务分库
	按照业务模块将数据分散到不同的数据库服务器
	带来的问题 join操作问题 事务问题 成本问题
分表
1. 垂直分表 复杂性：表操作的数量要增加
2. 水平分表 复杂性：路由(范围路由、配置路由)、join操作、count操作(count()相加、记录数表)、order by
实现方法
	程序代码封装
	中间件封装		

第16讲 高性能NoSQL
关系型数据库的缺点
1. 关系数据库存储的是列数据，无法存储数据结构
2. 关系数据库的schema扩展很不方便
3. 关系数据库在大数据场景下I/O较高
4. 关系数据库的全文搜索功能比较弱
NoSQL带来的优势，本质上是牺牲了ACID中的某个或某几个特性带来的，因此不能将NoSQL视为银弹
常见的NoSQL方案
1. K-V存储 解决无法存储数据结构问题 Redis
2. 文档数据库 解决强schem约束问题 MongoDB 优点：新增字段简单 历史数据不会出错 可以很容易存储复杂数据 缺点：不支持事务 无法实现关系数据库的join操作
3. 列式数据库 解决大数据场景下的I/O问题，以HBase为代表 优点：节省I/O，节省存储空间 劣势：频繁更新随机写效率低，适用于离线大数据分析和统计
4. 全文搜索引擎 解决全文搜索性能问题 ElasticSearch
NoSQL -> Not only SQL

第17讲 高性能缓存架构
存储系统的瓶颈
1. 需要经过复杂运算后得出的数据，存储系统无能为力
2. 读多写少的数据，存储系统有心无力
缓存穿透 缓存没有发挥作用，业务系统需要去存储系统查询数据
1. 存储数据不存在
2. 缓存数据生成耗费大量时间或者资源，在业务访问的时候缓存失效了
缓存雪崩 缓存失效(过期)后引起系统性能急剧下降的情况
1. 更新锁机制
2. 后台更新机制
缓存热点 大量请求命中同一份缓存数据打垮缓存服务器
1. 复制多份缓存副本，将请求分散到多个缓存服务器上，减轻由于缓存热点导致的单台缓存服务器压力

第18讲 单服务器高性能模型：PPC与TPC
高性能架构设计的两方面
1. 尽量提升单服务器性能，将单服务器的性能发挥到极致
2. 如果单服务器无法支撑性能，设计服务器集群方案
单服务器高性能的关键之一：服务器采取的并发模型
1. 服务器如何管理连接
2. 服务器如何处理请求  进程模型：单进程、多进程、多线程
PPC(Process Per Connection)  每个新连接新建进程
弊端
1. fork代价高
2. 父子进程通信复杂
3. 支持的并发连接数量有限
prefork 提前创建进程
TPC(Thread Per Connection) 每次有新的连接就新建一个线程去处理这个连接的请求
弊端
1. 创建还是有代价，高并发的时候还是有性能问题
2. 线程间的互斥和共享引入了复杂度，可能导致死锁问题
3. 多线程会出现互相影响的情况，某个线程出现异常，可能导致整个进程退出
prethread 提前创建线程
课后思考：
PPC和TPC能够支持的最大连接数都有上限，不适合高连接数场景，适合场景如下
1. 常量连接海量请求 数据库、redis、kafka等
2. 常量连接常量请求 企业内部网址

第19讲 单服务器高性能模式:Reactor与Proactor
Reactor 
核心组成部分 Reactor和处理资源池(进程池或线程池)，Reactor负责监听和分配事件，处理资源池负责处理事件
典型实现方案
1. 单Reactor 单进程/线程  适用于业务处理非常快速的场景 优点：简单，没有进程间通信。缺点，无法发挥多CPU性能；Handler处理某个连接上的业务时，整个进程无法处理其他连接的事件，容易导致性能瓶颈
2. 单Reactor 多进程/线程 优点：充分利用多核多CPU的处理能力 缺点：多线程数据共享和访问比较复杂；Reactor承担所有事件的监听和相应，只在主线程运行，瞬间高并发会成为性能瓶颈
3. 多Reactor 多进程/线程
Proactor
Reactor是非阻塞同步网络模型，真正的read和send都需要用户进程同步操作，将I/O操作改为异步能够进一步提升性能。
异步网络模型Proactor
能够利用DMA特性，linux的AIO不完善

第20讲 高性能负载均衡：分类及架构
高性能集群的复杂性主要体现在需要增加一个任务分配器，以及选择一个合适的任务分配算法
负载均衡系统分类
1. DNS负载均衡
2. 硬件负载均衡
3. 软件负载均衡
DNS负载均衡
	优点
    1. 简单、成本低
    2. 就近访问，提高访问速度
	缺点
    1. 更新不及时
    2. 扩展性差
    3. 分配策略比较简单
硬件负载均衡
	优点
    1. 功能强大
    2. 性能强大
    3. 稳定性高
    4. 支持安全防护
	缺点
    1. 价格昂贵
    2. 扩展性差	
软件负载均衡 nginx lvs
	优点
    1. 简单
    2. 偏移
    3. 灵活
	缺点
    1. 性能一般
    2. 功能没有硬件负载强大
    3. 安全特性差
常见组合 DNS实现地理级别负载均衡 硬件负载均衡实现集群级别负载均衡 软件负载均衡实现机器级别负载均衡

第21讲 高性能负载均衡：算法
常用负载均衡算法
1. 任务平分类
2. 负载均衡类 根据服务器负载来分配
3. 性能最优类 根据服务器的响应时间来分配
4. Hash类 根据任务中的某些关键信息进行Hash计算
轮询
	只要服务器在运行，不关注运行状态
加权轮询
	根据服务器权重进行任务分配，解决不同服务器处理能力有差异的问题
负载最低优先
	将任务分配给当前负载最低的服务器，根据任务类型和场景衡量指标不同。LVS用连接数、Nginx用HTTP请求数等
性能最优
	站在客户端角度来进行分配
Hash类
	根据某些关键信息进行Hash运算 原地址hash 适用于临时保存会话的场景 ID hash 同一次会话期间，用户每次都访问到同一台服务器
微信抢红包的高并发架构
1. 应用服务器的负载均衡，将任务分发到不同的应用服务器，轮询或加权轮询，速度快
2. 数据服务器，根据红包id进行hash负载均衡，将所有数据请求在同一台服务器上进行，防止多台服务器间的不同步问题

第22讲 CAP理论基础
在一个分布式系统中，当涉及读写操作时，只能保证一致性、可用性、分区容错性三者中的两个
分布式系统不一定会互联和共享数据(Memcache集群)，不符合CAP探讨的范畴
CAP关注的是对数据的读写操作，而不是分布式系统的所有功能
一致性：对某个指定的客户端来说，读写操作保证能返回最新的写操作结果（在事务执行过程中，系统其实处于一个不一致的状态，不同节点的数据并不完全一致）
可用性：非故障节点在合理的时间内返回合理的响应（不是错误和超时的响应）
分区容忍性：当出现网络分区后，系统能够继续履行职责
CA架构不可能选择，分布式环境必须选择P(分区容忍性)
CP架构 AP架构
思考题 Paxos算法了解

第23讲 CAP细节
CAP关键细节点
1. CAP关注的粒度是数据，而不是整个系统
2. CAP是忽略网络延迟的
3. 正常运行情况下，不存在CP和AP的选择，可以同时满足CA  架构设计的时候既要考虑分区发生时选择CP还是AP，也要考虑分区没有发生时如何保证CA
4. 放弃并不等于什么都不做，要为分区恢复后做准备
ACID
1. Atomicity 原子性 
2. Consistency 一致性
3. Isolation 隔离性 读未提交、读提交、可重读、串行化
4. Durability 持久性 
BASE 即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性 本质上是对AP方案的一个补充
1. 基本可用 Basically Available
2. 软状态 Soft State
3. 最终一致性 Eventual Consistency
读后感
分布式系统两大初衷：横向扩展和高可用性 横向扩展是为了解决单点瓶颈问题，进而保证高并发量下的可用性
为了保证可用性，一个分布式系统由多个节点构成，要保证各个节点的数据【一致性】
发生“网络分区”时，可以选择对用户表现出【一致性】即破坏可用性，也可以选择对用户表现出【可用性】即破坏一致性
没有P的单点子系统可以做到CA，但是单点系统并不是分布式系统，不在CAP理论的描述范围内
延伸思考
一个电商网站核心模块有会员、订单、商品、支付、促销管理等
会员模块，包括登录、个人设置、个人订单、购物车、收藏夹等，这些模块保证AP，数据短时间不一致不影响使用
订单模块的下单付款扣减库存是整个系统的核心，需要保证CA
商品模块的商品上下架和库存管理需要保证CP，搜索保证AP
促销保证AP
支付系统一般独立，C必须保证，AP中A更重要

第24讲 FMEA方法 排除架构可用性隐患
FMEA(Failure mode and effects analysis 故障模式与影响分析)
FMEA具体分析方法
1. 给出初始的架构设计图
2. 假设架构中某个部件发生故障
3. 分析此故障对系统功能造成的影响
4. 根据分析结果，判断架构是否需要进行优化
常见的FMEA分析表格包
1. 功能点 从用户角度看
2. 故障模式 表达故障现象即可
3. 故障影响 
4. 严重程度
5. 故障原因 不同故障原因发生概率不相同 不同故障原因检测手段不一样 不同的故障原因的处理措施不一样
6. 故障概率 关注点：硬件、开源系统、自研系统
7. 风险程度
8. 已有措施 检测告警、容错、自恢复等
9. 规避措施
10. 解决措施
11. 后续规划

第25讲 高可用存储架构：双机架构
高可用存储方案思路
1. 数据如何复制
2. 各个节点的职责是什么
3. 如何应对复制延迟
4. 如何应对复制中断
常见双机高可用架构 
	主备、主从、主备/主从切换、主主
主备复制 备机起备份作用，不承担读写
1. 优点 客户端不需要感知备机 主备只需要数据复制，无须进行状态判断和主备切换一类的复杂操作
2. 缺点 备机未提供读写操作，硬件成本有浪费 故障需要人工干预，无法自动恢复
主从复制 从机只负责读操作，不负责写操作
1. 优点 主机故障读操作相关业务可以继续运行 从机提供读操作发挥了硬件性能
2. 缺点 客户端需要感知主从关系，复杂度高 从机提供读业务在主从复制延迟大的情况下会出现数据不一致问题 故障需要人工干预
双机切换
三大关键设计点
1. 主备间状态判断 状态传递的渠道(相互连接、第三方仲裁)和状态检测的内容(是否掉电、进程是否存在、响应等)
2. 切换决策(切换时机、切换策略、自动程度)
3. 数据冲突解决
常见架构
互连式 主备机直接建立状态传递的渠道
1. 缺点 通道故障可能脑裂 增加通道无法根本解决问题，备机增加了状态判断的复杂度
中介式 主备两者之外引入第三方终结，主备机之间不直接连接
1. 优点 连接管理更简单 状态决策更简单
2. 缺点 中介自身的可用性问题
模拟式
1. 优点 实现更加简单
2. 缺点 基于有限状态决策，可能出现偏差
主主复制 两台机器都是主机，数据互相复制 适合于临时性、可丢失、可覆盖的场景
1. 优点 两台都是主机，不存在切换的概念 无需区分不同角色的主机
2. 缺点 很多数据双向复制会出现问题(主键ID、库存等)

第26讲 高可用存储架构 集群和分区
数据集群 数据集中集群和数据分散集群 多台服务器一起形成一个统一的系统
数据集中集群(主机写入数据)
复杂度体现(ZAB算法)
1. 主机如何将数据复制给备机
2. 备机如何检测主机状态
3. 主机故障后如何决定新的主机
数据分散集群(主机负责执行数据分配算法，可以是独立的一台机器，也可以是集群选择出的一台机器)
复杂度体现
1. 均衡性(保证服务器上的数据分区是基本均衡的)
2. 容错性
3. 可伸缩性
数据集中集群数据写到主机，数据分散集群可以向任意服务器中读写数据导致两者应用场景不同。
1. 数据集中集群适合数据量不大，集群机器数量不多的场景。
2. 数据分散集群适合业务数据量巨大，集群机器数量庞大的业务场景
数据分区 将数据按照一定规则进行分区，不同分区分布在不同的地理位置上，每个分区存储一部分数据，通过这种方式来避免地理级别的故障造成的巨大影响
数据分区架构关注点
1. 数据量
2. 分区规则 集中式 互备式 独立式
课后题 为什么不搭建远距离分布集群直接提供服务？
远距离集群网络延时高，出问题几率变大，成本高，引入的复杂度高

第27讲 如何设计计算高可用架构
设计复杂度：任务管理
关键点
1. 哪些服务器可以执行任务
2. 任务如何重新执行
常见的计算高可用架构：主备、主从、集群
主备 根据备机状态不同分为冷备和温备
主从
优缺点
1. 优点 主从架构的从机也执行任务，发挥了从机的硬件性能
2. 缺点 主从架构需要将任务分类，任务分配器会复杂一些
集群 对称集群(负载均衡集群)
对称集群
设计关键点
1. 任务分配器需要选取分配策略
2. 任务分配器需要检测服务器状态
非对称集群
设计关键点
1. 任务分配策略更加复杂 需要将任务划分为不同类型并分配给不同角色的集群节点
2. 角色分配策略实现比较复杂
课后题 计算高可用和存储高可用架构的复杂度对比
高可用需要冗余，计算高可用和存储高可用都会面对机器状态检测、切换以及机器选择问题，这点二者区别不大。
计算集群机器之间基本无交互，存储高可用还会涉及机器之间数据的同步和一致性问题，在同步时还要考虑性能、稳定性、同步终端、个别失败、重复同步等问题，总体来看存储高可用更为复杂

特别放送 如何高效地学习开源项目
看法
1. 不管什么身份，都可以从开源项目中学到很多东西
2. 不要只盯着数据结构和算法
3. 采取”自顶向下”的学习方法，源码不是第一步，而是最后一步
自顶向下学习法
1. 安装 系统的依赖组件 从安装目录获取使用和运行的基本信息 系统提供了哪些工具方便使用
2. 运行 从命令行和配置文件获取信息，系统具备哪些能力和系统将会如何运行
3. 原理研究 关键特性的基本实现原理 优缺点对比分析(只有掌握了优缺点才算真正掌握一门技术，才能在架构设计时做出合理选择)
4. 测试 测试一定要在原理研究之后做，不能安装完成立马就测试
5. 源码研究 不建议通读所有源码，而是带着目的针对性阅读
时间分配
1. 前三步必不可少
2. 四五看情况
 
第28讲 业务高可用的保障：异地多活架构
应用场景 异地 多活
异地多活的标准
1. 正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务
2. 某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务
异地多活的代价
1. 系统复杂度会发生质的变化，需要设计复杂的异地多活架构
2. 成本会上升，需要多部署一套或多套业务系统
综上所述，业务需要根据自己的实际场景觉得是否要上异地多活啊
架构模式 同城异区 跨城异地 跨国异地
同城异区 应对机房级别故障的最优架构
1. 优点 网络延时少，降低设计复杂度，减少了异地多活的设计和实现复杂度和成本
2. 缺点 无法应对大范围的故障
跨城异地 应对极端灾难场景
1. 优点 能够有效应对极端灾难事件
2. 缺点 大大提升了架构复杂度和中间传输的不可控因素。引入矛盾，数据不一致导致业务不正常，跨城异地肯定会导致数据不一致，数据一致性要求高的场景不可使用该架构。
跨国异地 多活的含义和前两者不一致
1. 为不同地区用户提供服务
2. 只读业务做多活
思考题 做了高可用存储的数据分区备份，又通过自动化运维保障1分钟内系统全部启动，是否需要做异地多活？
不可以，几点原因
1. 备份系统平时没有流量，如果直接上线可能触发平时测试不到的故障
2. 再实时的系统也会有数据延时，涉及数据强一致性要求的系统不能直接切换
3. 系统运行过程中有很多中间数据和缓存数据，不经过预热直接把流量倒过来容易把系统拖垮

第29讲 异地多活设计4大技巧
架构设计关键点
1. 同城异区 关键在于搭建高速网络达到类似本地机房的效果，架构设计上不用额外考虑
2. 跨城异地 解决数据不一致下，业务不受影响或者影响很小的矛盾
3. 跨国异地 面向不同地区提供业务或者提供只读业务，对架构设计要求不高
跨城异地多活架构设计技巧
1. 保证核心业务的异地多活 修改核心业务规则的代价很大，避免为了架构设计去改变业务规则
2. 保证核心数据最终一致性 1.尽量减少异地多活机房距离，搭建高速网络(成本高) 2.尽量减少数据同步，只同步核心业务相关数据 3.保证最终一致性，不保证实时一致性
3. 采用多种手段同步数据 1.消息队列方式 2.二次读取方式 3.存储系统同步方式 4.回源读取方式 5.重新生成数据方式
4. 只保证绝大部分用户的异地多活 可以采取异步处理的方式(银行转账，必须保证强一致性，提升用户体验)
核心思想 采用多种手段，保证绝大部分用户的核心业务异地多活
思考题 底层存储采用OceanBase这种分布式强一致性的数据存储系统，是否可以做到和业务无关的异地多活？
可以不考虑持久层的跨地域数据同步问题，但rt会变长，对业务还是有影响。除此之外还要解决缓存一致性问题，流量切到其他可用区的压力是否能承受住，需要业务降级。
无法做到业务无感知的异地多活。

第30讲 异地多活设计四步走
第一步 业务分级
常见分级标准
1. 访问量大的业务
2. 核心业务
3. 产生大量收入的业务
第二步 数据分类
常见数据特征分析维度
1. 数据量
2. 唯一性
3. 实时性
4. 可丢失性
5. 可恢复性
第三步 数据同步
常见数据同步方案
1. 存储系统同步
2. 消息队列同步
3. 重复生成
第四步 异常处理
常见的异常处理措施
1. 多通道同步 设计关键点 a. 一般情况双通道即可，更多通道更多成本 b. 数据库同步通道和消息队列同步通道不能复用网络连接 c. 数据可以重复覆盖
2. 同步和访问结合，适合实时性要求高的数据
3. 日志记录 a. 服务器上保存 b. 本地独立系统保存 c. 日志异地保存
4. 用户补偿 系统方案保证99.99%的用户，人工补偿弥补0.01%的用户
思考题 怎么处理业务分级？
了解产品挣钱的底层商业逻辑，从部门或者公司的当期发力点，预期价值和改造成本来进行业务分级。具体问题具体分析。

第31讲 如何应对接口级故障
导致接口级故障的场景原因
1. 内部原因 程序bug、慢sql、内存溢出等
2. 外部原因 黑客攻击，抢购流量、三方系统大量请求，依赖服务慢等
解决接口级服务核心思想：优先保证核心业务和优先保证绝大部分用户
几种保证方法
降级 将自身的业务或接口进行功能降级
常用的降级方式
1. 系统后门降级 成本低，后门低，有安全风险
2. 独立降级系统 
熔断 应对依赖的外部系统故障
防止由于依赖服务响应慢导致线程资源耗尽拖死自己服务
实现关键 1. 需要一个统一的API调用层 2. 阈值的设计
限流 从用户访问压力角度来考虑如何应对故障
只允许系统能够承受的访问量尽量，超出能力的请求将被丢弃
常见限流方式
1. 基于请求限流 限制总量 限制时间量
2. 基于资源限流 找到系统内部营销性能的关键资源，针对使用上限进行限制
排队
实际上是限流的变种，让用户等待一段时间
思考题 包含登录、抢购、支付等功能的整点限流秒杀系统如何设计接口级的故障应对手段？
对于用户服务，可以准备降级策略，保证登录可用，降级注册等非核心功能
对于抢购下单 可通过排队限流，商品信息等可做缓存进行灾备
对于支付依赖的第三方系统，合理设置熔断策略

第32讲 可扩展架构的基本思想和模式
架构的可扩展模式
魅力: 通过修改和扩展，不断让软件系统具备更多的功能和特性 难点:如何以最小的代价去扩展系统
可扩展的基本思想 拆！
常见的拆分思路
1. 面向流程拆分
2. 面向服务拆分
3. 面向功能拆分
学生信息管理系统为例进行拆分
1. 面向流程拆分 展示层 -> 业务层 -> 数据层 -> 存储层
2. 面向服务拆分 拆分为注册、登录、信息管理、安全设置等服务
3. 面向功能拆分 将每个服务拆分为更多细粒度的功能
不同的拆分方式，本质上决定了系统的扩展方式
可扩展方式
1. 面向流程拆分：分层架构
2. 面向服务拆分：SOA、微服务
3. 面向功能拆分：微内核架构
思考题 规则引擎属于哪一类？
解决了功能扩展的问题，应该是面向功能的扩展方式

第33讲 传统的可扩展架构模式：分层架构和SOA
分层架构
C/S架构、B/S架构
划分对象是整个业务系统，划分维度是用户交互
MVC架构、MVP架构
划分对象是单个业务子系统，划分维度是职责，各层的依赖关系比较灵活
逻辑分层架构
分层自顶向下依赖
分层架构核心是保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构
本质在于隔离关注点
通过分层强制约束两两依赖，可能会浪费一点性能，现代技术影响不严重
SOA 面向服务的架构
三个关键概念
1. 服务 所有业务功能都是一项服务
2. ESB 企业服务总线，屏蔽异构系统对外提供不同的接口方式，达到服务间高效的互通互联
3. 松耦合 减少各个服务间的依赖和互相影响 不容易，要做到完全后向兼容
比较高层级的架构设计理念，一般用于大BU，解决了IT系统重复建设和扩展效率低的问题，但也引入了更多复杂度，ESB是大坑
思考题 为什么互联网企业很少采用SOA架构？
SOA是把多个系统整合，微服务是把单个系统拆开来，方向正好相反。esb集中化的管理带来性能不佳，厚重等问题，也无法快速扩展，不适合互联网的业务特点。

第34讲 深入理解微服务架构：银弹 or 焦油坑？
微服务与SOA有什么关系？有什么区别？为何有了SOA还要提微服务？
微服务与SOA的关系
典型观点
1. 微服务是SOA的实现方式
2. 微服务是去掉ESB后的SOA
3. 微服务是一种和SOA相似但本质不同的架构理念(正确)
SOA和微服务的具体做法
1. 服务粒度 SOA的服务粒度要粗一些，微服务的服务粒度要细一些
2. 服务通信 SOA采用ESB作为服务间通信的关键组件，微服务推荐使用统一的协议和格式
3. 服务交付 SOA更多考虑兼容已有系统，微服务的架构理念要求”快速交付”
4. 应用场景 SOA更适合庞大、复杂、异构的企业级系统。微服务更加适合快速，轻量级，基于Web的互联网系统
微服务的陷阱
1. 服务划分过细，服务间关系复杂
2. 服务数量太多，团队效率急剧下降
3. 调用链太长，性能下降
4. 调用链太长，问题定位困难
5. 没有自动化支撑，无法快速交付
思考题 微服务实践中的经验教训
原则 微服务拆分要符合康威定律
打法A
1. 建设好基础设施、RPC、服务治理、日志、监控、持续集成、持续部署、运维自动化是基本的，其他包括服务编排、分布式追踪等
2. 要逐步演进和迭代，不要过于激进更不要拆分过细，拆分的粒度要与团队的架构相互匹配(康威定律)
3. 微服务与数据库方面是个很大的难点，可以深入了解下领域驱动设计，做好领域建模，特别是数据库要随着服务一起拆分

第35讲 微服务架构最佳实践 - 方法篇
微服务避免踩的陷阱
1. 微服务拆分过细，过分强调”small”
2. 微服务基础设施不健全，忽略了”automated”
3. 服务并不轻量级，规模大了之后，”lightweight”不再适应
服务粒度
两个披萨，三个火枪手
“三个火枪手”原则主要应用于微服务设计和开发阶段，维护期可以做适当的调整
拆分方法
1. 基于业务逻辑拆分 容易出现划分过粗或者过细的问题
2. 基于可扩展拆分 划分为”稳定服务”和”变动服务”，提升快速迭代的效率，避免影响已有功能
3. 基于可靠性拆分 拆分为核心服务和非核心服务 优点：避免非核心服务故障影响核心服务;核心服务高可用方案可以更简单;降低高可用成本
4. 基于性能拆分 拆分出性能要求高或者性能压力大的模块
基础设施
1. 服务发现、服务路由、服务容错：最基本的微服务基础设施
2. 接口框架、API网关：提升开发效率，接口框架提升内部服务开发效率，API网关提升与外部服务对接的效率
3. 自动化部署，自动化测试，配置中心：提升测试和运维效率
4. 服务监控、服务跟踪、服务安全：进一步提升运维效率
小结
如何把握拆分粒度，按照什么维度进行拆分，需要什么基础设施支持
思考题 自己所在的业务微服务架构是否有改进和提升的空间？

第36讲 微服务架构最佳实践 - 基础设施篇
一.自动化测试
服务拆分后，接口数量大大增加，快速交付，版本周期短，版本更新频繁，人工回归工作量大，效率低下，通过自动化测试系统来完成绝大部分测试回归工作
包括代码级的单元测试、单个系统级的集成测试、系统间的接口测试，至少要做到接口测试自动化
二.自动化部署
同理，人肉部署浪费人力且容易出错
包括版本管理、资源管理、部署操作、回退操作等
三.配置中心
节点多，需要统一的配置中心来管理所有微服务节点的配置
包括配置版本管理、增删改查配置、节点管理、配置同步、配置推送等
四.接口框架
一般采用HTTP/REST或者RPC方式统一接口协议
需要统一接口传递的数据格式
接口框架不是一个可运行的系统，一般以库或者包的形式提供给所有微服务调用
五.API网关
外部系统不需要理解内部微服务的职责分工和边界，它只会关注自己需要的能力，不会关注这个能力由哪个微服务提供
涉及安全和权限相关的限制，每个微服务自己实现工作量大而且都是重复工作
需要统一的API网关，负责外部系统的访问操作
包括接入鉴权、权限控制、传输加密、请求路由、流量控制等功能
六.服务发现
实现方式
1. 自理式 微服务自己完成服务发现，一般有统一的程序包实现，访问压力分散，性能和可用性不存在明显压力和风险
2. 代理式 微服务之间有一个负载均衡系统，由负载均衡系统来完成微服务之间的服务发现 负载均衡单点，有可用性和性能风险
核心都是服务注册表
七.服务路由
从符合条件的可用微服务节点挑选具体的节点发起请求
核心是路由算法
八.服务容错
节点数量大大增加带来某个微服务故障概率的增加
微服务具有故障扩散的特点，需要微服务有自动应对故障的能力
服务容错:重试、流控、服务隔离
九.服务监控
人力无法hold住，需要服务监控系统完成微服务节点的监控。
主要作用:
1. 实时搜集信息并进行分析，避免故障后再来分析，减少处理时间
2. 服务监控可以在实时分析基础上预警，在问题萌芽阶段发现预警，降低问题范围和时间
数据量大，建议独立系统而不是集成到服务发现，API网关等系统中
十.服务跟踪
跟踪请求在微服务中的完整路径
绝大多数实现基于Google的Dapper论文
十一.服务安全
数据分散后需要设计服务安全机制来保证业务和数据的安全性
分为三部分:接入安全、数据安全、传输安全
小结
微服务架构相关的基础设施的概要设计和关键设计点
思考题 十位高程、完全自研，完成所有的微服务基础设施开发，需要多久？
拆分多轮迭代，依据简单和演化原则和三个火枪手人员配置，系统上线后还要有留守同学，工期较长
预估工期最为考验能力

第37讲 微内核架构详解
基本架构
1. 核心系统 负责和具体业务功能无关的通用功能，比较稳定
2. 插件模块 负责实现具体的业务逻辑，根据业务功能需要不断扩展
设计关键点
1. 插件管理 插件注册表机制(常见实现)
2. 插件连接 插件如何连接到核心系统。一般由核心系统制定连接规范，插件按照规范实现，核心系统按照规范加载
3. 插件通信 插件间通信
OSGI架构简析
Open Services Gateway initiative，一般谈到OSGI指的是OSGI规范，而不是一个可运行的框架
逻辑架构图
1. 模块层 实现插件管理功能，插件被称为Bundle
2. 生命周期层 实现插件连接功能，提供执行时模块管理、模块对底层OSGI框架的访问，定义了Bundle生命周期的操作规范，由Bundle实现
3.  服务层 实现插件通信功能，提供服务注册功能，由插件将自己的服务注册到服务注册中心，
规则引擎架构简析
规则引擎中的执行引擎可以看作微内核
规则引擎应对海量业务规则的优势
1. 可扩展
2. 易理解
3. 高效率
规则引擎如何实现微内核架构的设计关键点
1. 插件管理 规则就是插件，引擎就是内核
2. 插件连接 规则引擎的插件连接实现机制其实就是规则语言
3. 插件通信 数据流和事件流，规则输出数据或者时间，由引擎将数据或者事件传递到下一个规则
JBoss Drools 常用规则引擎
小结
微内核设计关键点和常见的两种微内核具体实现
思考题 手淘Atlas容器化框架如何实现微内核架构的设计关键点？

第38讲 架构师应该如何判断技术演进的方向
典型派别
1. 潮流派 对于新技术热衷，紧跟技术潮流
2. 保守派 稳定压倒一切，一招打遍天下
3. 跟风派 跟着竞争对手的脚步走
不同派别可能存在的问题
1. 潮流派 容易成为新技术的”小白鼠”，掌握新技术有一定的成本
2. 保守派 不能享受新技术带来的收益
3. 跟风派 无风可跟怎么办？信息不全面可能会变成邯郸学步。
技术演进的动力
不能站在技术本身来思考问题，而应该站到一个更高的角度如企业业务发展来考虑
将企业的业务分为两类
一. 产品类 用户独占产品
技术创新推动业务发展
用户选择产品的根本驱动力是”功能”
二. 服务类 用户使用但不独占，用户越多，服务价值越大
业务推动技术发展
用户选择服务的根本驱动力是”规模”，”规模”成为决定因素后，服务模式的创新成为业务发展的核心驱动力
提出一种创新的服务模式->吸引一批用户->业务开始发展->吸引更多用户->服务模式不断完善和创新->吸引越来越多的用户，原有技术无法满足业务发展的需求
技术发展的主要驱动力是业务发展
技术演进的模式
基于业务发展阶段进行判断，架构师必须能够基于行业发展和企业自身情况做出准确判断
思考题 如果业界已经有了一个明显的参照对象，那架构师是否还需要按照步骤逐步演进，还是直接将架构一步到位设计好？
1. 结合激进、保守、跟风。作为架构的实践者，必须及时跟进新的技术体系，同时需要慎重考虑引进新的内容，要想清楚它的必要性，能在短期带来什么收益，解决什么问题，同时还需要以观察者的角度来看业界大厂的实践，同时思考他们为什么要这么做。
2. 架构的演进是有成本的，在准备改变之前要想明白做这件事的成本是什么，会给我们带来什么样的收益，当前的团队规模是否能稳定驾驭

第39讲 互联网技术演进的模式
互联网业务发展时期:初创期、发展期、竞争期、成熟期
不同时期的差别主要体现在两方面:复杂性，用户规模
业务复杂性 业务越来越复杂
一.初创期
业务的重点在于”创新”，对技术的唯一要求:”快！”
二.发展期
业务目标是不断完善，技术的核心工作是快速地实现各种需求
一般阶段
1. 堆功能期
2. 优化期 一般会分为”优化派”和”架构派”。一般优化派会赢，因为需要快速实现需求。优化派优化现有系统，重构，分层，优化查询语句，优化硬件等，速度快，遇到瓶颈也快。架构派调整系统架构，拆系统
3. 架构期 拆：拆功能、拆数据库、拆服务器
三.竞争期
新的系统越来越多，原有的系统也拆得越来越多，熵又增加了
系统量变到质变的体现
1. 重复造轮子
2. 系统交互一团乱麻
技术工作的主要解决手段
1. 平台化 解决”重复造轮子”的问题
2. 服务化 解决”系统交互”问题，通过消息队列完成系统间异步通知，通过服务框架完成同步调用
四.成熟期
大动作不多，更多的是进行优化
用户规模 不同阶段的差别就是用户量的差别
一.性能
用户量增大后单机扛不住了，只能将集中式转变为分布式，分布式会带来复杂度的大幅度提升。
二.可用性
用户规模越大，从口碑和收入上面不可用带来的影响也越来越大
量变到质变
模型
￼
未雨绸缪，在问题真正暴露出来之前根据趋势预测下一个转折点
思考题 是否存在典型的技术演进模式？

第四十讲 互联网架构模板：”存储层”技术
SQL
一般使用开源数据库 MySQL PG等，随着业务的发展需要对数据进行拆分
流行做法:独立成中间件
业务继续扩大即使使用中间件独立部署也会带来新的复杂度
1. 数据库资源使用率不高，比较浪费
2. 各SQL集群分开维护，投入的维护成本越来越高
大公司会选择构建SQL存储平台
NoSQL
数据结构的差异性和性能优势能够弥补关系数据库的不足，因此NoSQL的应用基本上是基础要求
本身一般提供集群功能，节点数量较大的时候可以考虑建立NoSQL存储平台，能够提升运维效率，提高资源利用效率
统一存储平台实现功能(规模小的话收益不大)
1. 资源动态按需动态分配
2. 资源自动化管理
3. 故障自动化处理
小文件存储
特征:1.数据小 2.数量巨大 3.访问量巨大
起步阶段就需要考虑，开源方案成熟，建议在开源方案基础上封装一个小文件存储平台
典型的小文件存储:淘宝的TFS、京东JFS、FB的Haystack
大文件存储
分类: 1.业务上的大数据 2.海量的日志数据
没有太多的选择，使用流行的开原方案，大公司会基于开源方案结合自己的业务特点封装大数据平台
小结
公司规模发展到一定阶段，基本是基于某个开源方案搭建统一的存储平台
思考题 为什么没有出现存储平台的开源方案，但云平台都提供了存储平台方案？
1. 存储平台开发成本高，需要高可用高性能
2. 需要使用存储平台的一般是大型公司
3. 云平台的存储平台是收费的，能为企业带来经济效益，开源的话投入巨大能使用的却很少
云平台的存储平台，面向的是所有用户包括大公司，有这方面需求，而且收费，能够为平台带来收入。开源存储平台，服务的用户很少，投入巨大，所以没有。

第四十一讲 互联网架构模板:”开发层”和”服务层”技术
开发层技术
一. 开发框架
小组间使用不同开发框架和技术的问题:
1. 技术人员之间没有共同的技术语言，交流合作少
2. 每类技术都需要投入大量资源熟练精通
3. 不同团队人员无法快速流动，人力资源不能高效利用
原则:优选成熟的框架，避免盲目追逐新技术
二. Web服务器
和语言有关，一开始不需要过度考虑性能
三. 容器
传统虚拟机解决了跨平台问题，但是过于庞大，启动慢，运行时占资源。Docker更轻量级。
Docker带来技术形势的改变
1. 运维方式会发生革命性变化，基于Docker打造自动化、智能化运维将成为主流方式
2. 设计模式会发生本质化的变化，启动新实例的代价低将鼓励设计思路朝“微服务”的方向发展
服务层技术
一. 配置中心
各个系统分散配置的缺点：上线效率低、处理线上问题效率低、自动检验机制难落地
配置中心通用化的好处:
1. 集中配置多个系统，操作效率高
2. 配置集中，检查方便，协作效率高
3. 可以实现程序化的规则检查
4. 相当于备份了系统的配置
二.服务中心
解决跨系统依赖的“配置”和“调度”问题
1. 服务名字系统
2. 服务总线系统
￼
三.消息队列
引入消息队列后的优点
1. 整体结构从网状结构变为线性结构，结构清晰
2. 消息生产和消息消费解耦，实现简单
3. 增加新的消息消费者，生产者不需要改动，扩展方便
4. 消息队列可以做高可用、高性能、避免各业务子系统独立做一套，减轻工作量
5. 业务子系统只需要聚焦业务，实现简单
思考题:使用统一的开发框架和开发语言，在高效的优点外会带来什么问题？
无法遵循合适原则

第四十二讲 互联网架构模板 网络层技术
负载均衡 将请求均衡地分配到多个系统上以应对大容量的访问
一. DNS
最简单也最常见，一般用来实现地理级别的负载均衡，不会做机器级别的负载均衡，因为太消耗IP资源
优点:通用、成本低
缺点:
1. DNS缓存时间长，删除机器后还是可能访问到
2. 不够灵活。无法感知后端服务器状态
自研方案:使用HTTP协议实现一个私有的DNS系统
HTTP-DNS优缺点:灵活、可控、及时、开发成本高、侵入性
二.Nginx、LVS、F5
实现同一地点内机器级别的负载均衡，Nginx是软件的7层负载均衡，LVS是内核的4层负载均衡，F5是硬件的4层负载均衡
区别在于性能和成本，设计方案的时候需要综合考虑方案和成本
三.CDN
将内容缓存在离用户最近的地方，用户访问缓存的内容，而不是站点的实时内容
很少有公司自己搭建CDN系统，一般从CDN服务商购买CDN服务
多机房
最核心的因素是如何处理时延带来的影响
一. 同城多机房
通过搭建私有的高速网络可以做到同机房的效果
二. 跨城多机房
机房间通过网络进行数据复制，由于时延问题业务需要做一定的妥协，如不要求实时强一致性而保证最终一致性
方案和业务有很强的相关性，例如转账之类需要强一致性的方案就不能这么做
三. 跨国多机房
由于时延太大和用户跨国访问实在太慢，跨国多机房一般仅用于备份和服务本国用户
多中心
相比多机房设计难度有本质的飞跃
多机房的主要目标是灾备，多中心要求多活
设计关键在于”数据一致性”和”数据事务性”如何保证
不一定所有业务都能实现多中心
思考题 为什么可以购买负载均衡和CDN服务，却不能购买多机房和多中心服务？
负载均衡和CDN基本和业务无关，具有通用性；而每个业务对数据的一致性和事务要求都不一样，需要单独设计，因此无法将多机房和多中心作为基础服务对外提供。

第四十三讲 互联网架构模板 “用户层”和”业务层”技术
用户层技术
一. 用户管理
用户管理的目标
1. 单点登录(SSO)，较成熟的开源方案(CAS)
2. 授权登录 较成熟的解决方案OAuth 2.0
主要问题:用户数量巨大，但实现并不困难，不同用户间业务关联不大，复杂均衡架构可以解决
二. 消息推送
基本上是调用API实现，技术上难度不大
APP主要分为IOS和Android推送，IOS较为规范和封闭(APNS),Android五花八门，一般不涉密使用第三方推送服务，涉密的话需要自己实现
消息推送功能:设备管理、连接管理、消息管理
技术上面临的挑战:
1. 海量设备和用户管理
2. 连接保活 黑活多，应用互相拉起，联系厂商开白名单等
3. 消息管理 消息定点推送，推荐使用微内核架构
三. 存储云，图片云
典型特点
1. 数据量大
2. 文件体积小
3. 访问时效性
实现技术: CDN + 小文件存储
为何拆分出存储云 + 图片云：图片业务复杂性，有裁剪、压缩、美化、审核等处理，拆分为独立系统提供服务
业务层技术
业务层面对的主要技术挑战: “复杂度”
屠龙宝刀: “拆”，具体拆分方案，分层架构、微服务、微内核等
复杂度过高时需要”合”，将职责关联比较强的子系统合成虚拟业务域，通过网关统一对外呈现
思考题 虚拟业务域的划分粒度？
粗一些，5+-2，参照管理学关于一层管理团队理想大小的理论

第四十四讲 互联网架构模板: “平台技术”
将重复的支撑功能做成平台，避免重复造轮子，减少不规范带来的沟通和协作成本
运维平台
核心职责
1. 配置 资源的管理:机器管理、IP地址管理、虚拟机管理等
2. 部署 将机器发布到线上 包管理、灰度发布管理、回滚等
3. 监控 负责收集系统上线后运行的相关数据，方便及时发现问题
4. 应急 主要负责系统出故障后的处理 停止程序、下线故障机器、切换IP等
核心设计要素 四化：标准化、平台化、自动化、可视化
1. 标准化 制定标准，没有标准化就没有运维平台
2. 平台化 a. 将运维标准固化到平台中，无序运维人员死记硬背 b. 平台提供简单方便的操作，相比之下人工操作低效且容易出错 c. 运维平台可复用，一套平台可以支撑成百上千个业务系统
3. 自动化 将重复手工操作固化下来，由系统自动完成
4. 可视化 a.直观地看到数据相关属性 b.将数据含义展示出来 c.将关联数据整合起来展示
测试平台 核心目的是提升测试效率，从而提升产品质量，设计关键是自动化
1. 用例管理 按照不同的维度将用例管理起来
2. 资源管理 管理硬件、软件、业务系统等资源，会使用虚拟技术来充分利用硬件资源
3. 任务管理 将测试用例分配到具体的资源上执行，跟踪任务的执行情况(测试平台设计的核心)
4. 数据管理 记录测试任务各类相关数据，沉淀数据便于后续利用
数据平台
核心职责
1. 数据管理 核心职责:数据采集、数据存储、数据访问、数据安全
2. 数据分析 细分领域:数据统计、数据挖掘、机器学习、深度学习
3. 数据应用 在线业务、离线业务 前提是”大数据”
管理平台
核心职责：权限管理
权限管理分为两部分
1. 身份认证 通常使用企业账号来做统一认证和登录
2. 权限控制 防止未经授权的人员进行操作
思考题 运维平台或者测试平台，中间件团队开发和运维或测试团队自己开发，各有什么优缺点
各有利弊，运维团队更了解自身需求，但需要具备相应的能力。

第四十五讲 架构重构内功心法第一式:有的放矢
演化 架构重构对架构师的要求更高
1. 业务已经上线，不能停下来
2. 关联方众多，牵一发动全身
3. 旧架构的约束
架构不满足业务发展的各种表现:系统响应慢、数据错误、某些用户访问失败；宕机、DB瘫痪、数据丢失;团队开发效率低等
架构师的首要任务:  从一大堆纷繁复杂的问题中识别出真正要通过架构重构来解决的问题，集中力量快速解决，而不是通过架构重构来解决所有问题。
新架构师或者TL要控制住自己的冲动
具体案例
一. 后台系统重构:解决不合理的耦合
M系统耦合了P业务独有的数据和所有业务公用的数据，导致可扩展性差
重构的目标是将游戏数据和业务数据拆分，解耦，能够各自独立快速发展
二. 游戏接入系统重构:解决全局单点的可用性问题
全局单点，一挂全挂
重构目标:实现双中心，机房故障另一个机房能顶上
三. X系统:解决大系统带来的开发效率问题
业务快速发展期大量东西被”塞”到同一个系统中，导致迭代困难容易踩坑
和M系统不同，相关功能都放在一个系统中导致系统可扩展性不足，同时所有功能都在一个系统中，导致一个功能出问题，整站不可用(慢sql导致整站拖慢)
要从众多问题中透过现象看到本质，找出真正的核心问题，有的放矢，既不会耗费大量的人力和时间投入，又能够解决核心问题
简单问题:从0开始设计当前系统，新老系统是否类似，差异不大优化即可
简单评价:重构后的问题，团队内部优化即可
思考题 目前的开发系统是否需要重构？原因和理由

第四十六讲 架构重构心法第二式:合纵连横
合纵
和利益相关方沟通好，达成一致共识，避免不必要的反复和争执
沟通协调时，将技术语言转换为通俗语言，以事实说话，以数据说话
举例: 
可扩展性差-版本迭代慢，需要考虑的其他业务多，收集数据用数据说话
可用性低-不要说几个9，整理线上故障的次数，影响的市场，影响的用户等，和其他系统的数据进行对比
连横
主要阻力:”这对我有什么好处”、”这部分我这边现在不急”
一. 这对我有什么好处
换位思考、合作共赢、关注长期
出现不可协调的利益性问题，需要协调更高层级的管理者推动
二. 这部分我们现在不急
换位思考，但要明确时间点；计划上灵活多变
思考题 推动和沟通为什么要架构师做，是否应该要项目经理做
1. 需求相对明确，周期明确，项目经理比较合适。架构重构可深可浅，不确定性多，沟通中又有很多技术专业性、细节性的东西，架构师去比较合适。
2. 诉求不同，项目经理的诉求是按时交付项目，架构师的诉求是架构合理演进
3. 架构重构，有时项目经理也在被游说的范围内

第四十七讲 架构重构心法第三式:运筹帷幄
在问题中挑选一个解决，操作简单，效果差，为什么？
1. 没有区分问题的优先级 无法集中资源解决最重要的问题
2. 没有将问题分类 相似问题没有统筹考虑，方案可能反复
3. 迫于业务版本的压力，专门挑容易做的实施 达不到重构的真正目的
X项目 识别出核心复杂度后制定总体策略 系统集成功能太多，扩展性不足；可用性不高，排查问题耗费大量人力
1. 救火 机器扩容 业务降级 立体化监控
2. 组件化 缓存组件化 队列组件化 接入服务中心
3. 解耦 核心和非核心业务分离 业务中台 公共功能组件化
某阶段集中解决一类问题 首先是效率高，其次是每个阶段都能看到明显成果，完成一、二阶段后，故障少了可以安心做服务化工作
S系统，可用性不高 无耦合
先救火，后优化，再重构
分段实施，将要解决的问题根据优先级、重要性、实施难度等划分为不同的阶段，每个阶段聚焦于一个整体的目标，集中精力和资源解决一类问题
1. 每个阶段都有明确的目标，做完后效果明显，团队信心足，后续推进更加容易
2. 每个阶段的工作量不会太大，可以和业务并行
3. 每个阶段的改动不会太大，降低了总体风险
如何指定分段实施的策略？
1. 优先级排序
2. 问题分类
3. 先易后难
4. 循序渐进
思考题 重构规划需要两年，怎么处理？
别重构了，重写吧

第四十八讲 再谈开源项目:如何选择、使用以及二次开发
DRY Don’t repeat yourself 不要重复造轮子
不要重复发明轮子，但要找到合适的轮子
如何选？ 如何选择一个开源项目
1. 聚焦是否满足业务，而不是项目是否优秀 遵循”合适”和”演化”原则
2. 聚焦是否成熟 可以考察的方面: 版本号、使用公司的梳理、社区活跃度
3. 聚焦运维能力 可以考察的方面: 日志是否齐全、是否有命令行、是否有故障检测和恢复的能力
如何用？如何使用开源项目
1. 深入研究，仔细测试 可以参考如何学习开源项目来研究下
2. 小心应用，灰度发布 敬畏线上，先在非核心业务上使用，有经验后慢慢扩展
3. 做好应急，以防万一 做好预案，尤其是存储，一定要有备份存储
如何改？如何基于开源项目做二次开发
1. 保持纯洁，加以包装 为什么不改？投入大、无法跟随原系统演化
2. 发明你要的轮子 没有完全适合自己的轮子，核心是考量成本和收益
思考题 倾向于购买云厂商提供的系统还是讲开源系统部署在云服务器上
如果公司规模小可以直接使用云厂商的产品，因为运维方便。业务大，有很多个性化配置和自己的整体监控系统等，不适合用云厂商产品，无法进行系统整合

第四十九讲 谈谈APP架构的演进
架构设计理念的关键点
1. 架构是系统的顶层设计
2. 架构设计的主要目的是为了解决软件系统复杂度带来的问题
3. 架构设计三原则：合适原则、简单原则、演化原则
4. 架构设计首先要遵循业界已经成熟的各种架构模式，然后再进行优化、调整、创新
Web App
包壳，Web的业务上包装一个App的壳
业务复杂度决定，解决”快速开发”和“低成本”问题，遵循”合适原则”和”简单原则”
劣势
1. 移动设备发展速度大于web技术发展速度，Web App的体验相比原生App差距越来越大
2. App承载的业务逻辑越来越复杂，进一步加剧体验问题
3. Web App无法利用移动设备的优化和改进，只有原生App可以
原生 App
遵循”演化原则”，能够更好地利用移动设备的优化和改进
Hybrid App
体验要求不高的采用Web方式实现，体验要求高的采用原生App方式实现，遵循”合适原则”
组件化 & 容器化
解决超级App的可扩展性问题，将超级App拆分为很多组件，遵循”演化原则”，业务复杂度高了才会采用
容器化和组件化区别主要在发布方式，组件化采用静态发布，容器化动态发布
跨平台App
很多公司提供了跨平台方案，但是体验上和原生App还是有一定差距
思考题 App架构接下来如何演进？
可能会平台统一化，出现类似Java和jvm关系的技术

第50讲 架构实战，架构设计文档模板
备选方案模板
一. 需求介绍 描述需求的背景、目标、范围等
二. 需求分析
5W 
Who 需求利益干系人
When 需求使用时间
What 需求的产出是什么
Where 需求的应用场景
Why 需求需要解决的问题
1H
How 关键业务流程
8C
8个约束和限制:性能、成本、时间、可靠性、安全性、合规性、技术性、兼容性
三. 复杂度分析 
1. 高可用
2. 高性能
3. 可扩展性
四. 备选方案
五. 备选方案评估
架构设计模板
一. 总体方案
核心内容架构图以及针对架构图的描述
二. 架构总览
三. 核心流程
四. 详细设计
五. 架构演进规划

第51讲 架构师成长之路
架构师内功包括三部分
1. 判断力 能够准确判断系统的复杂度在哪里
2. 执行力 能够用合适的方案解决复杂度问题
3. 创新力 能够创造新的解决方案解决复杂度的问题
能力的来源
1. 经验 设计过的系统越多，系统越复杂，无论成功失败都是经验
2. 视野 掌握的只是和技能越多、月神
3. 思考 将经验和视野中的模式、判断、选择、技巧等提炼出来为我所用
指导原则:积累经验、拓宽视野、深度思考
工程师 - 高级工程师 -技术专家- 初级架构师 - 中级架构师 - 高级架构师
工程师
典型特征：在别人的指导下完成开发
成长指导：基础技能积累阶段 Java语法、基本数据结构的使用、ide工具、CRUD操作、缓存使用、业务系统的基本流程等
高级工程师
典型特征：独立完成开发
成长指导：积累方案设计经验 和工程师阶段的差距 1. 深度，知道Why，掌握实现原理 2.理论 前人的成熟设计经验 数据库设计的范式，面向对象设计模式 SOLID设计原则，缓存设计理论等 系统学习，看书，研究源码
技术专家
典型特征:某个领域的专家
成长指导：拓展技术宽度 学习业界成熟的开源方案 研究业界的经验分享
初级架构师
典型特征:独立完成一个系统的架构设计 和技术专家的区别:架构师基于完善的架构设计方法论的指导来进行架构设计，技术专家更多的是基于经验进行架构设计
成长指导: 形成自己的”架构设计方法论” 系统学习架构设计方法论 深入研究成熟开源系统的架构设计 结合架构设计方法论，分析和总结各种系统的架构设计优缺点
中级架构师
典型特征:能够完成复杂系统的架构设计
成长指导: 技术深度和技术理论的积累
高级架构师
典型特征:创造新的架构模式
积累经验，把握机遇
总结
10000小时定律，持续不断的投入，学习、实践、思考总结
