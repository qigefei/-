# MySQL优化原理

## MySQL逻辑架构

* 客户端层(连接处理 + 授权认证 + 安全等) + 核心服务层(查询解析 + 分析 + 优化 + 缓存 + 内置函数 + 存储过程 + 触发器 + 视图等) + 存储引擎(数据存储 + 提取)

查询过程

* 客户端向MySQL服务器发送一条查询请求
* 服务器首先检查查询缓存，如果命中缓存返回缓存中结果，否则进入下一阶段
* 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
* MySQL根据执行计划，调用存储引擎的API来执行查询
* 将结果返回给客户端，同时缓存查询结果

## MySQL查询过程

* 很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行

### 客户端/服务端通信协议

* 半双工方式，服务端和客户端无法同时向对方发送数据
* 客户端用单独的数据包将查询请求发送给服务器，所以当查询语句过长时需要设置max_allowed_packet参数，如果查询实在太大，服务端会拒绝接收更多数据并抛出异常
* 服务器响应的数据会由多个数据包组成，但当服务器响应客户端请求时，客户端必须完整接收整个返回结果。因此在实际开发中需要尽量保持查询简单只返回必须的数据，减少通信间数据包的大小和数量。查询中尽量避免SELECT *以及加上LIMIT限制也是出于此原因

### 查询缓存

#### 缓存相关

* 缓存存放在一个引用表(类似HashMap)
* 包含用户自定义函数、存储函数、用户变了、临时表、mysql库中的系统表，其查询结果不会被缓存
* 表的数据或结构发生变化时缓存失效（写操作会带来系统消耗，特别是查询缓存非常大或碎片很多的情况下）
* 读操作也会带来额外的系统消耗(1.任何查询语句都必须经过检查 2.如果查询结果可以被缓存，执行完成后结果会写入缓存)
* 需要合理评估缓存带来的资源节约是否大于其本身消耗的资源

#### 对于查询缓存的建议

打开查询缓存并在数据库设计上做一些优化

* 用多个小表代替一个大表，注意不要过度设计
* 批量插入代替循环单挑插入
* 合理控制缓存空间大小(一般来说大小几十兆比较合适)
* 可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存

不要轻易打开缓存查询，特别是写密集型应用，实在需要打开将query_cache_type设置为DEMAND

### 语法解析和预处理

* MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。
* 这个过程主要通过语法规则来验证和解析。

### 查询优化

* 由优化器将语法树转化成查询计划。
* MySQL使用基于成本的优化器，选择其中成本最小的一个(不一定准)。

查询优化器的优化策略

* 重新定义表的关联顺序
* 优化MIN()和MAX()函数
* 提前终止查询
* 优化排序

### 查询执行引擎

根据生成的执行计划调用存储引擎实现的接口来得出结果

### 返回结果给客户端

是一个增量并且逐步返回的过程

## 性能优化建议

### Scheme设计与数据类型优化

* 通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引没救应该将该列设置为NOT NULL
* 对整数类型制定宽度没有意义，INT使用32位(4个字节)存储空间
* UNSIGED表示不允许复制，可以使正数的上限提高一倍。
* 没有太大必要使用DECIMAL，可以使用将数据乘以一百万然后使用BITINT存储，避免浮点值计算不准确和DECIMAL精确计算代价高的问题
* TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节，因此TIMESTAMP只能表示1970-2038年
* 大多数情况下没有使用枚举类型的必要，枚举的字符串列表固定，添加和删除字符串必须使用ALTER TABLE
* schema的列不要太多，存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换代价很高，如果列太多而实际使用的列又很少的话会导致CPU占用过高
* 大表的ALTER TABLE非常耗时，MySQL一般会用新的结构创建空表，然后将旧表的数据插入新表，再删除旧表，当内存不足而表又很大，并且有很大索引的时候耗时更久

### 创建高性能索引

避免事后添加索引

* 需要监控大量的SQL才能定位到问题
* 事后添加索引的时间远大于初始添加索引所需要的时间

#### 索引相关的数据结构和算法

* 一般使用B-Tree索引，大多数存储引擎都支持这种索引。
* 二叉查找树 平衡二叉树
* 索引一般存储在磁盘上，每读取一个节点，都需要一次磁盘I/O，二叉树深度太大耗时无法接受
* 减少树的深度，将二叉树变为m叉树，B+Tree就是一种多路搜索树
* 所有的数据都存储在叶子节点
* 非叶子节点并不存储真正的数据

#### 高性能策略

* MySQL不会使用索引的情况：非独立的列(索引列不能是表达式的一部分，也不能是函数的参数)
* 前缀索引 有效节约索引空间，提高索引效率
* 多列索引和索引顺序(在多个列上建立独立的索引并不能提高查询性能，老版随便选，新版采用合并索引的策略，对结果集的合并、排序等操作需要耗费大量的CPU和内存资源)，explain发现有索引合并(Extra字段出现Using union时需要检查下)
* 索引的顺序对于查询至关重要，应该把选择性更高的字段放到索引前面
* 避免多个范围条件，无法同时使用索引
* 覆盖索引(索引包含所有需要查询的字段的值)，好处:1.索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量 2.索引是按照列值顺序存储的，对于I/O密集型查询比随机从磁盘读取的IO要少的多
* 使用索引扫描来排序，在设计时尽量做到能够根据索引扫描来做排序
* 冗余和重复索引 已有索引(A,B),再创建索引(A)，一次查询可以只使用索引中的一部分，但只能是最左侧部分
* 删除长期未使用的索引

### 特定类型查询优化

#### 优化COUNT()查询
* 统计行数直接使用count(*)，意义清晰并且性能更好
* 使用近似值时使用EXPLAIN出来的行数时较好的选择(不会真正去查询，所以成本较低)

#### 优化关联查询

* 通过冗余字段关联比直接使用join有更好的性能
* 确保ON和USING字句的列上有索引，只需要在关联顺序的第二张表的相应列上创建索引
* 确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列

#### 优化limit分页
* 使用LIMIT加上偏移量的方法实现分页，配合索引效果不错
* 当偏移量大时代价较高，尽可能的使用覆盖索引扫描
* 使用延迟关联将大大提升查询效率
* 使用书签记录

#### 优化UNION

* MySQL处理union的策略是先创建临时表，然后将各个查询结果插入到临时表中，需要手动将where等字句下推到各个子查询中使优化器能够充分利用这些条件优化
* 尽量使用UNION ALL，否则MySQL会给临时表加上DISTINCT选项对整个临时表数据做唯一性检查，这样做代价很高


